
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    function isAuth() {
      return request.auth != null;
    }
    
    function isUser(userId) {
      return request.auth.uid == userId;
    }

    function isChatMember(chatId) {
      return isAuth() && get(/databases/$(database)/documents/chats/$(chatId)).data.members.hasAny([request.auth.uid]);
    }
    
    function isServerOwner(serverId) {
      return isAuth() && get(/databases/$(database)/documents/servers/$(serverId)).data.ownerId == request.auth.uid;
    }

    function isServerMember(serverId) {
        let server = get(/databases/$(database)/documents/servers/$(serverId)).data;
        return isAuth() && (request.auth.uid in server.members);
    }
    
    function isPublicServer(serverId) {
       return get(/databases/$(database)/documents/servers/$(serverId)).data.isPublic == true;
    }

    // Users: Allow read for any authenticated user, but write only for the user themselves.
    match /users/{userId} {
      allow read: if isAuth();
      allow create: if isUser(userId);
      allow update: if isUser(userId);
      allow delete: never;
    }

    // Chats & Messages: Users can only interact with chats they are members of.
    match /chats/{chatId} {
      allow read, update, delete: if isChatMember(chatId);
      allow create: if isAuth() && request.resource.data.members.hasAny([request.auth.uid]);
      
      match /messages/{messageId} {
        allow read, create: if isChatMember(chatId);
        allow update: if isChatMember(chatId) && request.resource.data.sender == request.auth.uid;
        allow delete: if isChatMember(chatId) && get(/databases/$(database)/documents/chats/$(chatId)/messages/$(messageId)).data.sender == request.auth.uid;
      }
    }
    
    // Servers & Channels: Complex rules for public/private servers and ownership.
    match /servers/{serverId} {
        allow read: if isPublicServer(serverId) || isServerMember(serverId);
        allow create: if isAuth();
        allow update: if isServerOwner(serverId) || (isServerMember(serverId) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members']));
        allow delete: if isServerOwner(serverId);

        match /channels/{channelId} {
            allow read: if isServerMember(serverId);
            allow create, update, delete: if isServerOwner(serverId);

            match /messages/{messageId} {
                allow read, create: if isServerMember(serverId);
                allow update: if isServerMember(serverId) && request.resource.data.sender == request.auth.uid;
                allow delete: if isServerMember(serverId) && get(/databases/$(database)/documents/servers/$(serverId)/channels/$(channelId)/messages/$(messageId)).data.sender == request.auth.uid;
            }
        }
    }
    
    // Friend Requests: Logic for sending, accepting, and declining requests.
    match /friendRequests/{requestId} {
        allow read: if isAuth() && (request.auth.uid == resource.data.from.id || request.auth.uid == resource.data.to);
        
        allow create: if isAuth() && request.resource.data.from.id == request.auth.uid;

        // Allow updates only for changing status by the recipient, or from pending by either party (e.g. cancel)
        allow update: if isAuth() && 
            (
                (request.auth.uid == resource.data.to && request.resource.data.status != resource.data.status) ||
                (resource.data.status == 'pending' && (request.auth.uid == resource.data.from.id || request.auth.uid == resource.data.to))
            );
            
      allow delete: never; // Use a status field instead of deleting
    }
  }
}
